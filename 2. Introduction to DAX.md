# Introduction to DAX

### Understanding DAX calculations
```sql
'Sales'[Quantity]              -- the reference of the quantity column in the Sales table

Sales[Quantity] * 2            -- This is a column reference

[Sales Amount] * 2             -- This is a measure reference

-- or // for single ligne comment

/* multiline comment */

```

### DAX data types
```sql
DAX data type          Power BI Data Type          Correspondent conventional SQL Data type

Integer                Whole Number                Integer/ INT
Decimal                Decimal Number              Floating point/ DOUBLE
Currency               Fixed Decimal Number        Currency/ MONEY
DateTime               DateTime, Date, Time        Date/ DATETIME
Boolean                True/False                  Boolean/ BIT
String                 Text                        String/ NVARCHAR(MAX)
Binary                 Binary                      Blob/ VARBINARY(MAX)
```

- Operator Overloading
```sql
Sales[OrderDatePlusOneWeek] = Sales[Order Date] + 7   -- The result is a date adding 7 days
```
n addition to operator overloading, DAX automatically converts strings into numbers and numbers into strings whenever 
required by the operator. For example, if we use the & operator, which concatenates strings, DAX converts its arguments into strings. 
The following formula returns “54” as a string:
```sql
= 5 & 4
```
On the other hand, this formula returns an integer result with the value of 9:
```sql
= "5" + "4"
```
The resulting value depends on the operator and not on the source columns, which are converted following the requirements 
of the operator. Moreover, not all the operators follow this behavior. For example, comparison operators cannot compare strings 
with numbers. Consequently, you can add one number with a string, but you cannot compare a number with a string.
To be more explicit, the previous example should be written like this:
```sql
= VALUE ( "5" ) + VALUE ( "4" )
```

- Integer:

DAX has only one Integer data type that can store a 64-bit value. All the internal calculations between integer values in DAX 
also use a 64-bit value.
- Decimal:

A Decimal number is always stored as a double-precision floating-point value. Do not confuse this DAX data type with the decimal 
and numeric data type of Transact-SQL. The corresponding data type of a DAX decimal number in SQL is Float.
- Currency:

The Currency data type, also known as Fixed Decimal Number in Power BI, stores a fixed decimal number. It can represent four decimal 
points and is internally stored as a 64-bit integer value divided by 10,000. Summing or subtracting Currency data types always ignores 
decimals beyond the fourth decimal point, whereas multiplication and division produce a floating-point value, thus increasing the 
precision of the result. In general, if we need more accuracy than the four digits provided, we must use a Decimal data type.
The default format of the Currency data type includes the currency symbol. We can also apply the currency formatting to Integer 
and decimal numbers, and we can use a format without the currency symbol for a Currency data type.

- DateTime:

DAX stores dates as a DateTime data type. This format uses a floating-point number internally, wherein the integer corresponds 
to the number of days since December 30, 1899, and the decimal part identifies the fraction of the day. Hours, minutes, and seconds 
are converted to decimal fractions of a day. Thus, the following expression returns the current date plus one day (exactly 24 hours):
```sql
= TODAY () + 1
```
If you need to take only the date part of a DateTime, always remember to use TRUNC to get rid of the decimal part.

- Boolean:

The Boolean data type is used to express logical conditions. For example, a calculated column defined by the following 
expression is of Boolean type:
```sql
 = Sales[Unit Price] > Sales[Unit Cost]
 ```
 You will also see Boolean data types as numbers where TRUE equals 1 and FALSE equals 0. This notation sometimes proves 
 useful for sorting purposes because TRUE > FALSE.
 
 - String:

Every string in DAX is stored as a Unicode string, where each character is stored in 16 bits. By default, the comparison 
between strings is not case sensitive, so the two strings “Power BI” and “POWER BI” are considered equal.

- Variant:

The Variant data type is used for expressions that might return different data types, depending on the conditions. 
For example, the following statement can return either an integer or a string, so it returns a variant type:
```sql
 IF ( [measure] > 0, 1, "N/A" )
 ```
The Variant data type cannot be used as a data type for a column in a regular table. A DAX measure, and in general, 
a DAX expression can be Variant.

- Binary:

The Binary data type is used in the data model to store images or other nonstructured types of information. It is not 
available in DAX. It was mainly used by Power View, but it might not be available in other tools such as Power BI.

### DAX Operators

```sql
Operator Type           Symbol       Use                            Example
-------------------------------------------------------------------------------------------------
Parenthesis             ()           Precedence order and           (5 + 2) * 3
                                     grouping of arguments  
-------------------------------------------------------------------------------------------------
Arithmetic              +            Addition                        4 + 2
                        -            Substraction/ negation          5 - 3
                        *            Multiplication                  4 * 2
                        /            Division                        4/2
-------------------------------------------------------------------------------------------------
Comparison              =            Equal to                        [CountryRegion] = "USA"
                        <>           Not equal to                    [CountryRegion] <> "USA"
                        >            Greater than                    [Quantity] > 0
                        >=           Greater than or equal to        [Quantity] >= 100
                        <            Less than                       [Quantity] < 0
                        <=           Less than or equal to           [Quantity] < = 100
--------------------------------------------------------------------------------------------------
Text concatenation      &            Concatenation of strings        "Value is" & [Amount]
--------------------------------------------------------------------------------------------------
Logical                 &&           AND condition                   [CountryRegion] = “USA” && [Quantity]>0
                        ||           OR condition                    [CountryRegion] = “USA” || [Quantity] > 0
                        IN           Inclusion of an element         [CountryRegion] IN {“USA”, “Canada”}
                        NOT          Boolean negation                 NOT [Quantity] > 0
--------------------------------------------------------------------------------------------------
 ```
 
Moreover, the logical operators are also available as DAX functions:
```sql
AND ( [CountryRegion] = "USA", [Quantity] > 0 )
OR ( [CountryRegion] = "USA", [Quantity] > 0 )
 ```
These examples are equivalent, respectively, to the following:
```sql
[CountryRegion] = "USA" && [Quantity] > 0
[CountryRegion] = "USA" || [Quantity] > 0
  ```
Using functions instead of operators for Boolean logic becomes helpful when writing complex conditions. In fact, when it comes to formatting large sections of code, functions are much easier to format and to read than operators are. However, a major drawback of functions is that we can pass in only two parameters at a time. Therefore, we must nest functions if we have more than two conditions to evaluate.

### Table constructor

In DAX we can define anonymous tables directly in the code. If the table has a single column, the syntax requires only a list of values—one for each row—delimited by curly braces. We can delimit multiple rows by parentheses, which are optional if the table is made of a single column. The two following definitions, for example, are equivalent:
```sql
{ "Red", "Blue", "White" }
{ ( "Red" ), ( "Blue" ), ( "White" ) }
  ```
If the table has multiple columns, parentheses are mandatory. Every column should have the same data type throughout all its rows; otherwise, DAX will automatically convert the column to a data type that can accommodate all the data types provided in different rows for the same column.
```sql
{
    ( "A", 10, 1.5, DATE ( 2017, 1, 1 ), CURRENCY ( 199.99 ), TRUE ),
    ( "B", 20, 2.5, DATE ( 2017, 1, 2 ), CURRENCY ( 249.99 ), FALSE ),
    ( "C", 30, 3.5, DATE ( 2017, 1, 3 ), CURRENCY ( 299.99 ), FALSE )
}
```
The table constructor is commonly used with the IN operator. For example, the following are possible, valid syntaxes in a DAX predicate:
```sql
'Product'[Color] IN { "Red", "Blue", "White" }
( 'Date'[Year], 'Date'[MonthNumber] ) IN { ( 2017, 12 ), ( 2018, 1 ) }
```
We can rewrite it using the IN operator with a table constructor that has a single row, as in the following example:
```sql
( 'Date'[Year], 'Date'[MonthNumber] ) IN { ( 2007, 12 ) }
```
### Conditional statements

In DAX we can write a conditional expression using the IF function. For example, we can write an expression returning MULTI or SINGLE depending on the quantity value being greater than one or not, respectively.
```sql
IF (
    Sales[Quantity] > 1,
    "MULTI",
    "SINGLE"
)
```
The IF function has three parameters, but only the first two are mandatory. The third is optional, and it defaults to BLANK. Consider the following code:
```sql
IF (
    Sales[Quantity] > 1,
    Sales[Quantity]
)
```
It corresponds to the following explicit version:
```sql
IF (
    Sales[Quantity] > 1,
    Sales[Quantity],
    BLANK ()
)
```

### Understanding calculated columns and measures

You need to learn one of the most important concepts in DAX: the difference between calculated columns and measures.

#### Calculated columns

Depending on the tool you are using, you can create a calculated column in different ways. Indeed, the concept remains the same: a calculated column is a new column added to your model, but instead of being loaded from a data source, it is created by resorting to a DAX formula.

#### Measures

Calculated columns are useful, but you can define calculations in a DAX model in another way. Whenever you do not want to compute values for each row but rather want to aggregate values from many rows in a table, you will find these calculations useful; they are called measures. For example, you can define a few calculated columns in the Sales table to compute the gross margin amount:
```sql
Sales[SalesAmount] = Sales[Quantity] * Sales[Net Price]
Sales[TotalCost] = Sales[Quantity] * Sales[Unit Cost]
Sales[GrossMargin] = Sales[SalesAmount] – Sales[TotalCost]
```
Measures and calculated columns both use DAX expressions; the difference is the context of evaluation. A measure is evaluated in the context of a visual element or in the context of a DAX query. However, a calculated column is computed at the row level of the table it belongs to. The context of the visual element depends on user selections in the report or on the format of the DAX query. Therefore, when using SUM(Sales[SalesAmount]) in a measure, we mean the sum of all the rows that are aggregated under a visualization. However, when we use Sales[SalesAmount] in a calculated column, we mean the value of the SalesAmount column in the current row.
A measure needs to be defined in a table. This is one of the requirements of the DAX language. However, the measure does not really belong to the table. Indeed, we can move a measure from one table to another table without losing its functionality.


